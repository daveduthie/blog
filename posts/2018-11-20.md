## Strings in differential dataflow

In the course of using differential dataflow, you may find yourself using types that contain strings. In [one case of program analysis](https://github.com/frankmcsherry/differential-dataflow/tree/master/doop) that I've been working with, the input records look like:

```
<sun.font.SunFontManager$14: void <init>()> <init>  ()  sun.font.SunFontManager$14  void    ()V 0
<sun.awt.image.VSyncedBSManager$SingleVSyncedBSMgr: void <init>()>  <init>  ()  sun.awt.image.VSyncedBSManager$SingleVSyncedBSMgr   void    ()V 0
<javax.swing.AbstractAction: boolean shouldReconfigure(java.beans.PropertyChangeEvent)> shouldReconfigure   (java.beans.PropertyChangeEvent)    javax.swing.AbstractAction  boolean (Ljava/beans/PropertyChangeEvent;)Z 1
<sun.font.SunFontManager$14: void <init>()> <init>  ()  sun.font.SunFontManager$14  void    ()V 0
...
<java.awt.geom.AffineTransform: void transform(double[],int,double[],int,int)>  transform   (double[],int,double[],int,int) java.awt.geom.AffineTransform   void    ([DI[DII)V  5
<java.awt.geom.AffineTransform: void transform(double[],int,double[],int,int)>  transform   (double[],int,double[],int,int) java.awt.geom.AffineTransform   void    ([DI[DII)V  5
<java.awt.geom.AffineTransform: void transform(double[],int,double[],int,int)>  transform   (double[],int,double[],int,int) java.awt.geom.AffineTransform   void    ([DI[DII)V  5
...
<org.gjt.sp.jedit.pluginmgr.MirrorList: void readXml()> readXml ()  org.gjt.sp.jedit.pluginmgr.MirrorList   void    ()V 0
<sun.nio.cs.StandardCharsets$Aliases: void init(java.lang.Object[])>    init    (java.lang.Object[])    sun.nio.cs.StandardCharsets$Aliases void    ([Ljava/lang/Object;)V  1
<sun.nio.cs.StandardCharsets$Aliases: void init(java.lang.Object[])>    init    (java.lang.Object[])    sun.nio.cs.StandardCharsets$Aliases void    ([Ljava/lang/Object;)V  1
<org.gjt.sp.jedit.pluginmgr.MirrorList: void readXml()> readXml ()  org.gjt.sp.jedit.pluginmgr.MirrorList   void    ()V 0
...
```

Barf.

These are a bunch of strings, basically. There are some tabs in there to break things apart (maybe they survived the copy/paste, but maybe not). These particular records have a type that is essentially

```rust
[String; 6]
```

And we need to perform maps, filters, joins, grouping, and even iteration, all using strings.

### Strings work!

Before anything too exciting, the `String` type totally works in differential dataflow. You can go and do graph computations where the node type is `String`, or `(Vec<String>, bool)`, or whatever crazy types you kids use to do graph processing in Javascript (lol, I know... "types").

The `String` type works but it can be a bit inefficient when compared to `usize`, which is just a much simpler type to work with when we want to hash-distribute records, or sort records, or group them by keys. It is also much easier to clone a `usize` than a `String`; the latter means we must allocate some memory and most likely de-allocate it at some future point.

### Interning Strings

While `String` works, we might like to perform something like [string interning](https://en.wikipedia.org/wiki/String_interning), in which each of the string instances are replaced by one representative instance.

Instead, let's try replacing each string with a unique integer identifier. We lose the ability to do string-y operations, like substrings and converting to upper and lower case, but we can still do equality testing and hash-distribution, and many of the things we need to do in our data-parallel compute lifestyle.

Single-threaded, this would be super easy:

```rust
    /// Ensure `string` exists in `map`, return unique identifier.
    fn intern(string: String, map: &mut HashMap<String, usize>) -> usize {
        let len = map.len();
        *map.entry(string)
            .or_insert(len)
    }
```

Whenever we intern a string, we either return its existing identifier or add it with a new distinct identifier and return that.

This skips a few fun issues like do we ever *remove* interned strings (not here), how to we look up strings from their identifiers (second map, I guess), and maybe a few other issues. We aren't going to stick with this approach, but it is good to see that it isn't all that painful.

### Interning Strings *IN DIFFERENTIAL DATAFLOW*

Let's write a fairly simple computation that will intern strings using differential dataflow.

Can't we just use the above fragment? Sure, sure. I did that in the code linked up above. It works, it's totally fine, but it just feels a bit gross and non-robust. For example, we have to do all of the data loading on one thread, because we can't intern the strings in parallel. If the set of strings changes dramatically, we keep all of the pre-existing strings around grotting up the place. Also c'mon, this is going to be neat and you might learn something. :D

As a first, guess, couldn't we just intern strings by hashing each of them and using the hash as the integer identifier? Almost, but there could be collisions. How about, if there are collisions, we pick one winner and re-hash the others?

Winner!

```rust
let interned =
strings
    // initialize each string at "round" zero.
    .map(|string| (0, string))
    .iterate(|temp| {
        // propose a candidate hash from (round, string),
        // group by hash and pick at most one winner,
        //       defer non-winners to the next round.
        temp.map(|rs| (rs.hashed(), rs))
            .group(|_hash, input, output| {
                // first (round, string) wins!
                output.push((input[0].0.clone(), 1));
                // if any losers, increment their rounds.
                for ((round, string),_count) in input[1..].iter() {
                    output.push(((*round+1, string.clone()), 1));
                }
            })
            .map(|(_hash, rs)| rs)
    })
    .map(|rs| (rs.hashed(), rs.1));
```

This works great. Each string in `strings` gets a fairly random hash in round zero, and if there are any collisions we pick a winner (the earliest round, breaking ties lexicographically by string) and promote the losers to the next round. We don't really expect many collisions, and we really don't expect any one string to repeatedly collide with other strings (assuming our `.hashed()` method is worth anything).

What happens when we have a change in our input strings?

Not very much, which is great news! There was so little interaction of strings, that there are similarly sparse changes to their interactions. Perhaps if we remove a winner we end up finding the string or two it collided with and naming them winner, but most of the time we add a string and give it an identifier or remove a string and remove its binding to an identifier.

### Using interned strings

Way back up there we had some horrible `[String; 6]` folks that reminded us about Java and that evil still walks the Earth. How do we wire together a string interning fragment (like just above) with our stream of Java six-tuples?

I'll show you a pretty naive version, and I point out how to do it more smartly and leave it as homework!

The most naive way to do things is to i. extract the candidate strings to intern, and then ii. repeatedly join the six-tuples with the interned strings to extract identifiers for each coordinate at a time.

```rust
    // Each six-tuple offers six strings to intern.
    let strings = six_tuples.flat_map(|x| x);

    let interned =
    strings
        // Copy-paste that stuff up above ...
        ;

    let string_to_hash = interned.map(|(hash, string)| (string, hash));

    six_tuples
        // map each to (next_key, ([hashes], [strings])).
        .map(|x| (x[0], ([], x[1..5])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..6])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..5])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..4])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..3])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..2])))
        .join_map(string_to_hash, |_k,h,(hs,ss)| (ss[0], ((hs,h), ss[1..1])))
```

Ok, now all those `join_map` closures aren't actually legit Rust, but I hope you get the gist about what is going on. Six times, we extract the first remaining string and use `join_map` to find us an integer hash value to replace it, and keep the remaining strings.

---

**HOMEWORK**: The approach above has the defect that five times, we arrange and maintain the strings that we have not yet interned, which is pretty silly. It's not the end of the world, but seriously...

The good news is that we recently got [some sweet join tech](https://github.com/frankmcsherry/differential-dataflow/tree/master/dogsdogsdogs) that lets us implement "delta queries" in differential dataflow, those being join evaluation strategies that do not materialize intermediate relations, and which could potentially maintain *only* the `string_to_hash` collection in indexed form.